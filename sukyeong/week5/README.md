# 자바스크립트 내용 정리

### 자바스크립트란?

:point_right: 자바 스크립트는 객체 기반 스크립트 언어입니다.  
HTML이 웹의 내용을 담당하고, CSS가 웹의 디자인을 담당한다면, 자바스크립트는 **웹의 동작**을 담당합니다.
자바스크립트에서는 '이벤트'라는 단어를 많이 볼 수 있는데요, 이는 자바스크립트가 웹에 입력되는 다양한 이벤트에 맞게 반응하는 웹 페이지를 구현할 수 있도록 하는 언어이기 때문입니다.

자바스크립트는 다음과 같은 특징을 가지고 있습니다.

-   자바스크립트는 타입을 명시할 필요가 없는 인터프리터 언어입니다.
-   자바와는 전혀 다른 언어입니다. 자바스크립트 이름을 지을 당시에, 자바가 각광받고 있는 것을 보고 자바에서 이름을 따왔다는 말이 있습니다.
-   웹페이지 UI를 동적으로 보여주는 역할을 하지만, Node.js를 활용하면 서버쪽에서도 사용할 수 있습니다.

---

### 자주 쓰이는 자바스크립트 코드

:point_right: 자바스크립트에서 자주 활용되는 코드를 살펴봅시다.

1. 출력 코드

```
console.log("Hello World!")
```

자바스크립트에서는 출력할 때, print가 아닌 **console.log** 를 사용합니다.  
이는 console이라는 **객체** 안에서 log라는 **메소드**를 불러오는 것을 의미합니다.
이는 HTML의 p태그처럼 웹에 출력되는 것이 아니라 콘솔에 출력되는 형태입니다.

2. let, const  
   자바스크립는 타입을 따로 명시하진 않지만, 새로운 변수를 지정할 때 let이나 const를 가장 많이 씁니다. let은 변수를 지정한 뒤, 추후에 변수에 저장된 값을 바꿔도 되지만 const는 상수이므로 바꿀 수 업습니다.

```
let num = 12
let num = 16
console.log(num)  // 16 출력
```

```
const PI = 3.14
const PI = 3.15
console.log(PI)  // 에러 출력
```

3. 객체  
   자바스크립트는 객체 지향 언어이기 때문에, 객체를 생성할 수 있습니다.

```
const Info = {
    name: "Mike",
    age: 20,
    male: true,
    school: "Hanyang University"
}

console.log(Info.age)  // 20 출력
```

4. addEventListener  
   바닐라 자바스크립트를 하게 될 경우, 동작을 구현하기 위해 가장 많이 쓰이게 될 메소드인 것 같습니다.

```
// 버튼을 "누르면" handleSubmit 함수를 호출한다 (동작)
button.addEventListener("click", handleSubmit)
```

여기서 주의할 점은, handleSubmit이 함수지만, 뒤에 ()를 붙이지 않는다는 것입니다.  
그 이유는, js 파일이 실행되자마자 함수를 호출할 것이 아니라 버튼을 누르는 순간에만 호출되는 함수이기 때문입니다.

---

### HTML이랑 연동하기

:point_right: 웹페이지에서 활용하는 언어인 만큼, 자바스크립트는 HTML과 연동할 수 있습니다.  
HTML body태그 가장 하단부에 아래와 같은 코드를 적으면 됩니다.

```
<body>
<h1>Hello World</h1>
<p>This is an example code</p>
...
<script src="index.js"></script>
</body>
```

가장 밑에 script태그를 사용해서 자바스크립트와 HTML을 연동해줄 수 있습니다.  
<br>
<br>
그 후, 자바스크립트 파일에서 HTML에 있는 클래스나 태그,id 등을 사용하고 싶다면, 아래와 같은 메소드를 활용해주면 됩니다.

```
const hello = document.getElementById("hello")
const title = document.getElementByClassName("title")
const header = document.querySelector(".header")
```

자바스크립트는 기본 표기법이 CamelCase이기 때문에 유의해서 사용하면 됩니다.
또한 getElementById나 getElementByClassName은 id를 가져올 지, class를 가져올 지 정확하게 명시되어 있지만, querySelector은 명시해주어야 합니다.

-   Id를 가져올 때는 # 표기
-   Class를 가져올 때는 . 표기
-   Tag를 가져올 때는 표기하지 않음

---

### 동기, 비동기

:point_right: 많은 웹 사이트에서 더 빠른 웹 사이트를 구현하려고 하는 이유가 있는데요,
바로 **고객이 웹 사이트가 열리기까지 기다리는 평균 시간이 3초** 이기 때문입니다. 3초가 지나면 소비자는 느리다고 생각하거나, 다른 웹 사이트를 이용하려고 할 것입니다.  
그렇다면, 각 학교에서 성적 정보를 가져와서 취업 가능성을 알려주는 웹 사이트를 만들 것이라고 가정해봅시다.
소비자가 내 웹사이트를 이용하려고 자신의 학교 정보를 입력했습니다. 그렇다면 웹사이트에서는,

1. 새 페이지로 전환한다. (취업 가능성 결과를 알려주는 페이지)
2. 고객의 성적을 API로 들고 온다.
3. 성적을 바탕으로 취업이 가능한지 결과를 화면에 출력한다.

이 순서대로 일을 진행해야 합니다. 하지만! 웹 페이지에서 성적 API를 들고 오려고 다른 서버로 갔는데, 그 사이에 취업 결과 페이지가 먼저 출력될 수도 있습니다. 성적을 들고 오지도 않았는데 말입니다. 그 이유는, 1번을 실행하고, 2번을 실행했는데, 2번이 오래걸리면 2번이 끝날 때까지 기다리는 것이 아니라 2번을 이미 시작했으니, 3번을 시작하려는 자바스크립트의 **'비동기적 성향'** 때문입니다. 순서대로 실행을 해도, 시간이 오래 걸리면 다음 순서를 미리 실행하는 것입니다. 웹 페이지는 시간이 생명이니까요.
<br>
하지만 성적 정보를 가져오지 않으면, 이 웹페이지는 의미가 없습니다. 이러한 문제를 해결하기 위해 성적 정보를 가져올 때까지 기달려달라고 웹페이지에 말해야 합니다.
그래서 순서를 이와 같이 만들 수 있습니다.

1. 새 페이지로 전환한다. (취업 가능성 결과를 알려주는 페이지)
2. 고객의 성적을 API로 들고 온다 -> **다 들고 올 때까지 기다려줘!**
3. 화면에 아무것도 출력하지 않으면, 고객은 오래걸린다고 생각하므로 API를 들고 올 때까지 **로딩페이지**를 띄운다 (UI/UX적 측면)
4. **API를 성공적으로 불러오면,** 그 때 성적을 바탕으로 취업이 가능한지 결과를 화면에 출력한다.  
   <br>

이렇듯 비동기적인 성향이 디폴트인 자바스크립트를 사용할 때, 무조건 기다려줘야 하는 상황들은 동기적으로 표현해서, 필요한 순서를 놓치고 지나치는 일이 없도록 만들 수 있습니다. 그 방법 중에는 **Promise** 와 **Async/Await** 이 있습니다.

---

### Promise

:point_right: Promise를 사용하면, 동기적으로 실행 순서를 정할 수 있습니다.

```
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(
  result => alert(result), // 1초 후 "done!"을 출력
  error => alert(error) // 실행되지 않음
);

```

위와 같은 예시 코드를 보면, promise라는 변수 안에 Promise 함수를 저장하였습니다. 함수를 실행하면 '성공'하거나 '실패'하거나 둘 중 하나를 하게 됩니다. promise는 1000밀리초가 지나면 성공을 해서 done을 출력하게 되는데, promise.then은 promise의 실행이 다 끝나면 실행되므로, promise 속에 있는 setTimeOut을 안 기다리고 먼저 실행될 일이 없습니다.

---

### Async / Await

:point_right: async가 붙은 함수는 반드시 프로미스를 반환하고, await은 프로미스가 처리될 때까지 기다렸다가, await의 결과를 그 이후에 반환합니다. await은 async 함수 안에서만 동작합니다.

```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // 프라미스가 이행될 때까지 기다림

  alert(result); // "done!" 출력
}

f();
```

result는 프로미스가 이행될 때까지 기다렸다가 프로미스가 끝나면 "done!"을 저장하고, 그 후, alert(result)를 실행합니다. await 덕분에 promise가 "done!"을 반환하지 않았는데 이미 alert가 호출될 일은 없는 것입니다.
